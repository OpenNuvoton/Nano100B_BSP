<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nano100BN Series BSP: SPI_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="M0Banner_v2.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nano100BN Series BSP
   &#160;<span id="projectnumber">V3.03.002</span>
   </div>
   <div id="projectbrief">The Board Support Package for Nano100BN Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">SPI_T Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a069fd6acdea1842f24bba35267ff3ea5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a069fd6acdea1842f24bba35267ff3ea5">CTL</a></td></tr>
<tr class="separator:a069fd6acdea1842f24bba35267ff3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe2cb0c518f0dff54c05986b987f33"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4afe2cb0c518f0dff54c05986b987f33">STATUS</a></td></tr>
<tr class="separator:a4afe2cb0c518f0dff54c05986b987f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea1e761f8c180884bc051c73db22e13"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a6ea1e761f8c180884bc051c73db22e13">CLKDIV</a></td></tr>
<tr class="separator:a6ea1e761f8c180884bc051c73db22e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5d65619694a5df1436bb9bc1f548d4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#acd5d65619694a5df1436bb9bc1f548d4">SSR</a></td></tr>
<tr class="separator:acd5d65619694a5df1436bb9bc1f548d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47737acb74f2f2d9349a981d095b57"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a7c47737acb74f2f2d9349a981d095b57">RX0</a></td></tr>
<tr class="separator:a7c47737acb74f2f2d9349a981d095b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a62ec07fe66de05dbcb70bcce2a1f3272">RX1</a></td></tr>
<tr class="separator:a62ec07fe66de05dbcb70bcce2a1f3272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf28b6d289035f03cbe294af78b345b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a9bf28b6d289035f03cbe294af78b345b">RESERVE0</a> [2]</td></tr>
<tr class="separator:a9bf28b6d289035f03cbe294af78b345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a2e6b1c45e89186b0b38d4d5a03dfa063">TX0</a></td></tr>
<tr class="separator:a2e6b1c45e89186b0b38d4d5a03dfa063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d2928ba639001d0282683b53ceaf3"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a390d2928ba639001d0282683b53ceaf3">TX1</a></td></tr>
<tr class="separator:a390d2928ba639001d0282683b53ceaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3af89b804bed7e4c2d7805fec32e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a0ff3af89b804bed7e4c2d7805fec32e4">RESERVE1</a> [3]</td></tr>
<tr class="separator:a0ff3af89b804bed7e4c2d7805fec32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762fced4160de55295b4d0854f24f66d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a762fced4160de55295b4d0854f24f66d">VARCLK</a></td></tr>
<tr class="separator:a762fced4160de55295b4d0854f24f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a436021c5a67252e0ae2e95d9ef9e4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#af7a436021c5a67252e0ae2e95d9ef9e4">DMA</a></td></tr>
<tr class="separator:af7a436021c5a67252e0ae2e95d9ef9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_p_i___t.html#a4cd9a89d3d1c7a3a6f3e3c5c4beb0727">FFCTL</a></td></tr>
<tr class="separator:a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SPI Serial Peripheral Interface Controller(SPI)
Memory Mapped Structure for SPI Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09190">9190</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a6ea1e761f8c180884bc051c73db22e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea1e761f8c180884bc051c73db22e13">&#9670;&nbsp;</a></span>CLKDIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CLKDIV </h1>
<h2>Offset: 0x08 SPI Clock Divider Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]  </td><td class="markdownTableBodyCenter">DIVIDER1  </td><td class="markdownTableBodyLeft">Clock Divider 1 Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Where   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">is the SPI engine clock source. It is defined in the CLK_SEL1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]  </td><td class="markdownTableBodyCenter">DIVIDER2  </td><td class="markdownTableBodyLeft">Clock Divider 2 Register   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the 2nd frequency divider of the PCLK to generate the serial clock of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The desired frequency is obtained according to the following equation:   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09364">9364</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a069fd6acdea1842f24bba35267ff3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069fd6acdea1842f24bba35267ff3ea5">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>CTL </h1>
<h2>Offset: 0x00 SPI Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">GO_BUSY  </td><td class="markdownTableBodyLeft">SPI Transfer Control Bit And Busy Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing this bit "0" will stop data transfer if SPI is transferring.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the transfer is finished, this bit will be cleared automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can read this bit to check if the SPI is in busy status.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit will be controlled by hardware.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software should not modify this bit.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In slave mode, this bit always returns 1 when software reads this register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In master mode, this bit reflects the busy or idle status of SPI.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. When FIFO mode is disabled, all configurations should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_NEG  </td><td class="markdownTableBodyLeft">Receive At Negative Edge   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received data is latched on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received data is latched on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_NEG  </td><td class="markdownTableBodyLeft">Transmit At Negative Edge   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted data output is changed on the rising edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted data output is changed on the falling edge of SPI_SCLK.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:3]  </td><td class="markdownTableBodyCenter">TX_BIT_LEN  </td><td class="markdownTableBodyLeft">Transmit Bit Length   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many bits can be transmitted / received in one transaction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The minimum bit length is 8 bits and can be up to 32 bits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TX_BIT_LEN Description   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01000 8 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01001 9 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">---&mdash; -------&mdash;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11111 31 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00000 32 bits are transmitted in one transaction   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">LSB  </td><td class="markdownTableBodyLeft">Send LSB First   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BITLEN, is transmitted/received first.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]  </td><td class="markdownTableBodyCenter">CLKP  </td><td class="markdownTableBodyLeft">Clock Polarity   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The default level of SCLK is low in idle state.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The default level of SCLK is high in idle state.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]  </td><td class="markdownTableBodyCenter">SP_CYCLE  </td><td class="markdownTableBodyLeft">Suspend Interval (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = "0".   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKP = "1", the interval is from the rising clock edge to the falling clock edge.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is 0x3. The desired suspend interval is obtained according to the following equation:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SP_CYCLE[3:0) + 0.5) * period of SPICLK   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Ex:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x0 ... 0.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0x1 ... 1.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xE ... 14.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SP_CYCLE = 0xF ... 15.5 SPICLK clock cycle.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the Variable Clock function is enabled, the minimum period of suspend interval (the transmit data in FIFO buffer is not empty) between the successive transaction is (6.5 + SP_CYCLE) * SPICLK clock cycle   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]  </td><td class="markdownTableBodyCenter">INTEN  </td><td class="markdownTableBodyLeft">Interrupt Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI Interrupt Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI Interrupt Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]  </td><td class="markdownTableBodyCenter">SLAVE  </td><td class="markdownTableBodyLeft">Slave Mode   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI controller set as Master mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI controller set as Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]  </td><td class="markdownTableBodyCenter">REORDER  </td><td class="markdownTableBodyLeft">Byte Reorder Function Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable byte reorder function   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable byte reorder function and insert a byte suspend interval among each byte.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The suspend interval is defined in SP_CYCLE.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. The byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. In Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">3. The byte reorder function is not supported when the variable serial clock function or the dual I/O mode is enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]  </td><td class="markdownTableBodyCenter">FIFOM  </td><td class="markdownTableBodyLeft">FIFO Mode Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Normal mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. Before enabling FIFO mode, the other related settings should be set in advance.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set "1" automatically after the data was written into the 8-depth FIFO.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The user can clear this FIFO bit after the transmit FIFO status is empty and the GO_BUSY back to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]  </td><td class="markdownTableBodyCenter">TWOB  </td><td class="markdownTableBodyLeft">2-Bit Transfer Mode Active   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 2-bit transfer mode Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 2-bit transfer mode Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note that when enabling TWOB, the serial transmitted 2-bits data are from SPI_TX1/0, and the received 2-bits data input are put into SPI_RX1/0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]  </td><td class="markdownTableBodyCenter">VARCLK_EN  </td><td class="markdownTableBodyLeft">Variable Clock Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The serial clock output frequency is fixed and only decided by the value of DIVIDER1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The serial clock output frequency is variable.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1, and DIVIDER2.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]  </td><td class="markdownTableBodyCenter">DUAL_IO_DIR  </td><td class="markdownTableBodyLeft">Dual IO Mode Direction   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Date read in the Dual I/O Mode function.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data write in the Dual I/O Mode function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29]  </td><td class="markdownTableBodyCenter">DUAL_IO_EN  </td><td class="markdownTableBodyLeft">Dual IO Mode Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dual I/O Mode function Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dual I/O Mode function Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]  </td><td class="markdownTableBodyCenter">WKEUP_EN  </td><td class="markdownTableBodyLeft">Wake-Up Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled when the system enters Power-down mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the system enters Power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09291">9291</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="af7a436021c5a67252e0ae2e95d9ef9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a436021c5a67252e0ae2e95d9ef9e4">&#9670;&nbsp;</a></span>DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::DMA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>DMA </h1>
<h2>Offset: 0x38 SPI DMA Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">TX_DMA_EN  </td><td class="markdownTableBodyLeft">Transmit PDMA Enable (PDMA Writes Data To SPI)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to 1 will start the transmit PDMA process.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI controller will issue request to PDMA controller automatically.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DMA controller inside SPI controller will set it automatically whenever necessary.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. Two transaction need minimal 18 APB clock + 8 SPI serial clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 serial clocks for level mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Hardware will clear this bit to 0 automatically after PDMA transfer done. If FIFO mode not release, it should be remove.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_DMA_EN  </td><td class="markdownTableBodyLeft">Receiving PDMA Enable(PDMA Reads SPI Data To Memory)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to "1" will start the receive PDMA process.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SPI controller will issue request to PDMA controller automatically when there is data written into the received buffer or the status of RX_EMPTY status is set to 0 in FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If using the RX_PDMA mode to receive data but TX_DMA is disabled, the GO_BUSY bit shall be set by user.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Hardware will clear this bit to 0 automatically after PDMA transfer done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive transactions input is need to be larger than 9 SPI slave engine clock + 4 APB clock for edge mode and 9.5 SPI slave engine clock + 4 APB clock   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">PDMA_RST  </td><td class="markdownTableBodyLeft">PDMA Reset   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to reset the SPI PDMA function into default state.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = After reset PDMA function or in normal operation.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset PDMA function.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: it is auto cleared to "0" after the reset function done.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09526">9526</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a4cd9a89d3d1c7a3a6f3e3c5c4beb0727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9a89d3d1c7a3a6f3e3c5c4beb0727">&#9670;&nbsp;</a></span>FFCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::FFCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>FFCTL </h1>
<h2>Offset: 0x3C SPI FIFO Control Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_CLR  </td><td class="markdownTableBodyLeft">Receiving FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to clear the receiver counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">TX_CLR  </td><td class="markdownTableBodyLeft">Transmitting FIFO Counter Clear   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to clear the transmit counter in FIFO Mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">RXINT_EN  </td><td class="markdownTableBodyLeft">RX Threshold Interrupt Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Rx threshold interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX threshold interrupt Enable.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">TXINT_EN  </td><td class="markdownTableBodyLeft">TX Threshold Interrupt Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Tx threshold interrupt Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX threshold interrupt Enable.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">RXOVINT_EN  </td><td class="markdownTableBodyLeft">RX FIFO Over Run Interrupt Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO over run interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO over run interrupt Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">TIMEOUT_EN  </td><td class="markdownTableBodyLeft">RX Read Timeout Function Enable   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX read Timeout function Disabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX read Timeout function Enabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26:24]  </td><td class="markdownTableBodyCenter">RX_THRESHOLD  </td><td class="markdownTableBodyLeft">Received FIFO Threshold   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">3-bits register, value from 0 ~7.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RX valid data counts large than RXTHRESHOLD, RXINT_STS will set to 1, else RXINT_STS will set to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30:28]  </td><td class="markdownTableBodyCenter">TX_THRESHOLD  </td><td class="markdownTableBodyLeft">Transmit FIFO Threshold   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">3-bit register, value from 0 ~7.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX valid data counts small or equal than TXTHRESHOLD, TXINT_STS will set to 1, else TXINT_STS will set to 0   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09562">9562</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a9bf28b6d289035f03cbe294af78b345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf28b6d289035f03cbe294af78b345b">&#9670;&nbsp;</a></span>RESERVE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE0[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09446">9446</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a0ff3af89b804bed7e4c2d7805fec32e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3af89b804bed7e4c2d7805fec32e4">&#9670;&nbsp;</a></span>RESERVE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SPI_T::RESERVE1[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09480">9480</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a7c47737acb74f2f2d9349a981d095b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c47737acb74f2f2d9349a981d095b57">&#9670;&nbsp;</a></span>RX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX0 </h1>
<h2>Offset: 0x10 SPI Receive Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09431">9431</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a62ec07fe66de05dbcb70bcce2a1f3272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec07fe66de05dbcb70bcce2a1f3272">&#9670;&nbsp;</a></span>RX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>RX1 </h1>
<h2>Offset: 0x14 SPI Receive Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">RDATA  </td><td class="markdownTableBodyLeft">Receive Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The received data can be read on it.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: These registers are read only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09445">9445</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="acd5d65619694a5df1436bb9bc1f548d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5d65619694a5df1436bb9bc1f548d4">&#9670;&nbsp;</a></span>SSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SSR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>SSR </h1>
<h2>Offset: 0x0C SPI Slave Select Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]  </td><td class="markdownTableBodyCenter">SSR  </td><td class="markdownTableBodyLeft">Slave Select Active Register (Master Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.(the same as SSR[1] for SPISS[1])   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is set, writing "1" to any bit location of this field will select appropriate SPISS[1:0] line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(The active level of SPISS[1:0] is specified in SS_LVL).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1. This interface can only drive one device/slave at a given time.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2. SPISS[0] is also defined as device/slave select input in Slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">SS_LVL  </td><td class="markdownTableBodyLeft">Slave Select Active Level   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It defines the active level of device/slave select signal (SPISS[1:0]).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The SPI_SS slave select signal is active Low.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI_SS slave select signal is active High.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">AUTOSS  </td><td class="markdownTableBodyLeft">Automatic Slave Selection (Master Only)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If this bit is set as "1", SPISS[1:0] signals are generated automatically.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">SS_LTRIG  </td><td class="markdownTableBodyLeft">Slave Select Level Trigger   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input slave select signal is edge-trigger.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal will be level-trigger.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It depends on SS_LVL to decide the signal is active low or active high.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]  </td><td class="markdownTableBodyCenter">NOSLVSEL  </td><td class="markdownTableBodyLeft">No Slave Selected In Slave Mode   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is used to ignore the slave select signal in Slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The controller is 4-wire bi-direction interface.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The controller is 3-wire bi-direction interface in Slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In no slave select signal mode, the SS_LTRIG, SPI_SSR[4], shall be set as "1".   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">SLV_ABORT  </td><td class="markdownTableBodyLeft">Abort In Slave Mode With No Slave Selected   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In normal operation, there is interrupt event when the received data meet the required bits which define in TX_BIT_LEN.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the received bits are less than the requirement and there is no more serial clock input over the time period which is defined by user in slave mode with no slave select, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is auto cleared to "0" by hardware when the abort event is active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]  </td><td class="markdownTableBodyCenter">SSTA_INTEN  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable interrupt when the transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Tansfer start interrupt Disabled.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transaction start interrupt Enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]  </td><td class="markdownTableBodyCenter">SS_INT_OPT  </td><td class="markdownTableBodyLeft">Slave Select Interrupt Option   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable the interrupt when the transfer has done in slave mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No any interrupt, even there is slave select inactive event.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = There is interrupt event when the slave select is inactive.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to inform the user the transaction has finished and the slave select into the inactive state.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09417">9417</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a4afe2cb0c518f0dff54c05986b987f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afe2cb0c518f0dff54c05986b987f33">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>STATUS </h1>
<h2>Offset: 0x04 SPI Status Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]  </td><td class="markdownTableBodyCenter">RX_EMPTY  </td><td class="markdownTableBodyLeft">Received FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]  </td><td class="markdownTableBodyCenter">RX_FULL  </td><td class="markdownTableBodyLeft">Received FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Received data FIFO is not full in dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Received data FIFO is full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]  </td><td class="markdownTableBodyCenter">TX_EMPTY  </td><td class="markdownTableBodyLeft">Transmitted FIFO_EMPTY Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 =Transmitted data FIFO is empty in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]  </td><td class="markdownTableBodyCenter">TX_FULL  </td><td class="markdownTableBodyLeft">Transmitted FIFO_FULL Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmitted data FIFO is not full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmitted data FIFO is full in the dual FIFO mode.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]  </td><td class="markdownTableBodyCenter">LTRIG_FLAG  </td><td class="markdownTableBodyLeft">Level Trigger Accomplish Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transferred bit length of one transaction does not meet the specified requirement.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transferred bit length meets the specified requirement which defined in TX_BIT_LEN.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is READ only.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the software sets the GO_BUSY bit to 1, the LTRIG_FLAG will be cleared to 0 after 4 SPI engine clock periods plus 1 system clock period.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In FIFO mode, this bit is unmeaning.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]  </td><td class="markdownTableBodyCenter">SLV_START_INTSTS  </td><td class="markdownTableBodyLeft">Slave Start Interrupt Status   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to dedicate that the transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave started transfer no active.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer has started in Slave mode with no slave select.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is auto clear by transfer done or writing one clear.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]  </td><td class="markdownTableBodyCenter">INTSTS  </td><td class="markdownTableBodyLeft">Interrupt Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transfer is not finished yet.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transfer is done. The interrupt is requested when the INTEN bit is enabled.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing "1" to this bit.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]  </td><td class="markdownTableBodyCenter">RXINT_STS  </td><td class="markdownTableBodyLeft">RX FIFO Threshold Interrupt Status (Read Only)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX valid data counts small or equal than RXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX valid data counts bigger than RXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If RXINT_EN = 1 and RX_INTSTS = 1, SPI will generate interrupt.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]  </td><td class="markdownTableBodyCenter">RX_OVER_RUN  </td><td class="markdownTableBodyLeft">RX FIFO Over Run Status   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will dropped.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to itself.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]  </td><td class="markdownTableBodyCenter">TXINT_STS  </td><td class="markdownTableBodyLeft">TX FIFO Threshold Interrupt Status (Read Only)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX valid data counts bigger than TXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX valid data counts small or equal than TXTHRESHOLD.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]  </td><td class="markdownTableBodyCenter">TIME_OUT_STS  </td><td class="markdownTableBodyLeft">TIMEOUT Interrupt Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = There is not timeout event on the received buffer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is not empty and there is not be read over the 64 SPI_CLK period in master mode and over the 576 ECLK period in slave mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the received FIFO is read by user, the timeout status will be cleared automatically.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to itself.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]  </td><td class="markdownTableBodyCenter">RX_FIFO_CNT  </td><td class="markdownTableBodyLeft">Data counts in RX FIFO (Read Only)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:20]  </td><td class="markdownTableBodyCenter">TX_FIFO_CNT  </td><td class="markdownTableBodyLeft">Data counts in TX FIFO (Read Only)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09346">9346</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a2e6b1c45e89186b0b38d4d5a03dfa063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b1c45e89186b0b38d4d5a03dfa063">&#9670;&nbsp;</a></span>TX0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX0 </h1>
<h2>Offset: 0x20 SPI Transmit Data FIFO Register 0 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x08, the bit SPI_TX[7:0] will be transmitted in next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09463">9463</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a390d2928ba639001d0282683b53ceaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d2928ba639001d0282683b53ceaf3">&#9670;&nbsp;</a></span>TX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>TX1 </h1>
<h2>Offset: 0x24 SPI Transmit Data FIFO Register 1 </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">TDATA  </td><td class="markdownTableBodyLeft">Transmit Data FIFO Register   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Registers hold the data to be transmitted in the next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if TX_BIT_LEN is set to 0x08, the bit SPI_TX[7:0] will be transmitted in next transfer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09479">9479</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<a id="a762fced4160de55295b4d0854f24f66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762fced4160de55295b4d0854f24f66d">&#9670;&nbsp;</a></span>VARCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::VARCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1>VARCLK </h1>
<h2>Offset: 0x34 SPI Variable Clock Pattern Flag Register </h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits  </th><th class="markdownTableHeadCenter">Field  </th><th class="markdownTableHeadLeft">Descriptions   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]  </td><td class="markdownTableBodyCenter">VARCLK  </td><td class="markdownTableBodyLeft">Variable Clock Pattern Flag   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the frequency patterns of the SPICLK.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit pattern of VARCLK is '0', the output frequency of SPICLK is according the value of DIVIDER1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit patterns of VARCLK are '1', the output frequency of SPICLK is according the value of DIVIDER2.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is used for CLKP = 0 only.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_nano100_series_8h_source.html#l09496">9496</a> of file <a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Users/yachen/workzone/bsp/nano100bbsp/Library/Device/Nuvoton/Nano100Series/Include/<a class="el" href="_nano100_series_8h_source.html">Nano100Series.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 18:20:58 for Nano100BN Series BSP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
